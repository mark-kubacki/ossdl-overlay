Index: setup.py
===================================================================
--- setup.py	(revision 4755)
+++ setup.py	(working copy)
@@ -22,7 +22,7 @@
     "setuptools >= 0.6c2",
     "simplejson >= 1.3",
     "TurboCheetah >= 1.0",
-    "TurboJson >= 1.1.2",
+    "TurboJson >= 1.1.3, < 1.2",
     "TurboKid >= 1.0.4",
 ]
 
Index: turbogears/i18n/format.py
===================================================================
--- turbogears/i18n/format.py	(revision 4755)
+++ turbogears/i18n/format.py	(working copy)
@@ -1,182 +1,181 @@
+"""Localized formatting functions.
+
+These functions extract localization data from config files located
+in the data/directory.
+
 """
-Localized formatting functions. These functions extract localization data
-from config files located in the data/directory.
-"""
 
 from turbogears.i18n.utils import get_locale
 import pkg_resources
 import os
 import re
 
-def is_locale_format(locale):
 
+def is_locale_format(locale):
+    """Check if locale is supported."""
     py_filename = pkg_resources.resource_filename(
-            "turbogears.i18n.data", "%s.py" %locale)
-    if os.path.exists(py_filename):return True
-
+        "turbogears.i18n.data", "%s.py" % locale)
+    if os.path.exists(py_filename):
+        return True
     pyc_filename = pkg_resources.resource_filename(
-            "turbogears.i18n.data", "%s.pyc" %locale)
-    if os.path.exists(pyc_filename):return True
-
+            "turbogears.i18n.data", "%s.pyc" % locale)
+    if os.path.exists(pyc_filename):
+        return True
     return False
 
-def get_locale_module(locale):
 
+def get_locale_module(locale):
+    """Get i18n module supporting the locale."""
     try:
         # check if locale is supported. If not, check again with
         # first part of locale for example, "fi_FI" > "fi".
-
         if not is_locale_format(locale):
-
             locale = locale[:2]
-
-        name = "turbogears.i18n.data.%s" %locale
-
+        name = "turbogears.i18n.data.%s" % locale
         mod = __import__(name)
         parts = name.split(".")[1:]
-        for p in parts:mod = getattr(mod, p)
+        for p in parts:
+            mod = getattr(mod, p)
         return mod
-
     except (ImportError, AttributeError):
         return None
 
-def get(locale, name, default=None):
 
+def get(locale, name, default=None):
+    """Get an attribute value for the locale."""
     locale = get_locale(locale)
     mod = get_locale_module(locale)
-
     return getattr(mod, name, default)
 
+
 def get_countries(locale=None):
-    """
-    Returns list of tuples, consisting of international country code
-    and localized name, e.g. ('AU', 'Australia')
-    """
+    """Get all supported countries.
 
+    Returns a list of tuples, consisting of international country code
+    and localized name, e.g. ('AU', 'Australia').
+
+    """
     countries = get(locale, "countries", {}).items()
-    countries.sort(lambda x,y:cmp(x[1], y[1]))
+    countries.sort(lambda x, y: cmp(x[1], y[1]))
     return countries
 
-def get_country(key, locale=None):
-    """
-    Returns localized name of country based on international country code
-    """
 
+def get_country(key, locale=None):
+    """Get localized name of country based on international country code."""
     return get(locale, "countries", {})[key]
 
+
 def get_languages(locale=None):
-    """
-    Returns list of tuples, with language code and localized name,
-    e.g. ('en', 'English')
-    """
+    """Get all supported languages.
 
+    Returns a list of tuples, with language code and localized name,
+    e.g. ('en', 'English').
+
+    """
     languages = get(locale, "languages", {}).items()
-    languages.sort(lambda x,y:cmp(x[1], y[1]))
+    languages.sort(lambda x, y: cmp(x[1], y[1]))
     return languages
 
-def get_language(key, locale=None):
-    """
-    Returns localized name of language based on language code
-    """
 
+def get_language(key, locale=None):
+    """Get localized name of language based on language code."""
     return get(locale, "languages", {})[key]
 
+
 def get_month_names(locale=None):
-    """Returns list of full month names, starting with January
-    """
+    """Get list of full month names, starting with January."""
     return get(locale, "months", [])
 
-def get_abbr_month_names(locale=None):
-    """Returns list of abbreviated month names, starting with Jan
-    """
 
+def get_abbr_month_names(locale=None):
+    """Get list of abbreviated month names, starting with Jan."""
     return get(locale, "abbrMonths", [])
 
-def get_weekday_names(locale=None):
-    """Returns list of full weekday names
-    """
 
+def get_weekday_names(locale=None):
+    """Get list of full weekday names."""
     return get(locale, "days", [])
 
-def get_abbr_weekday_names(locale=None):
-    """Returns list of abbreviated weekday names
-    """
 
+def get_abbr_weekday_names(locale=None):
+    """Get list of abbreviated weekday names."""
     return get(locale, "abbrDays", get_weekday_names(locale))
 
-def get_decimal_format(locale=None):
 
+def get_decimal_format(locale=None):
+    """Get decimal point for the locale."""
     return get(locale, "numericSymbols").get("decimal", ".")
 
-def get_group_format(locale=None):
 
+def get_group_format(locale=None):
+    """Get digit group separator for thousands for the locale."""
     return get(locale, "numericSymbols").get("group", ",")
 
+
 def format_number(value, locale=None):
-    """
-    Returns number formatted with grouping for thousands,
-    e.g. 5000000>5,000,000
-    """
+    """Get number formatted with grouping for thousands.
 
-    gf = get_group_format(locale)
+    E.g. 5000000 will be formatted as 5,000,000.
 
-    thou=re.compile(r"([0-9])([0-9][0-9][0-9]([%s]|$))" %gf).search
-
-    v=str(value)
-    mo=thou(v)
+    """
+    gf = get_group_format(locale)
+    thou = re.compile(r"([0-9])([0-9][0-9][0-9]([%s]|$))" % gf).search
+    v = str(value)
+    mo = thou(v)
     while mo is not None:
-        l = mo.start(0)
-        v=v[:l+1]+gf+v[l+1:]
-        mo=thou(v)
+        i = mo.start(0)
+        v = v[:i+1] + gf + v[i+1:]
+        mo = thou(v)
     return unicode(v)
 
+
 def format_decimal(value, num_places, locale=None):
-    """
-    Returns number formatted with grouping for thousands and correct
-    notation, e.g. 5000000.898>5,000,000.898
-    """
+    """Get number formatted with grouping for thousands and decimal places.
 
-    format = "%%.%df"%num_places
-    str = format%value
-    num, decimals = str.split(".")
-    return unicode(
-            format_number(num, locale) + get_decimal_format(
-            locale) + decimals)
+    E.g. 5000000.898 will be formatted as 5,000,000.898.
 
-def format_currency(value, locale=None):
     """
-    Returns formatted currency value
-    """
+    v = ("%%.%df" % num_places) % value
+    if num_places == 0:
+        return format_number(v, locale=locale)
+    num, decimals = v.split(".", 1)
+    return format_number(num, locale) + unicode(
+        get_decimal_format(locale) + decimals)
 
+
+def format_currency(value, locale=None):
+    """Get formatted currency value."""
     return format_decimal(value, 2, locale)
 
+
 def parse_number(value, locale=None):
-    """
-    Takes localized number string and returns a long integer
-    (or throws ValueError if bad format)
-    """
+    """Take localized number string and return a long integer.
 
+    Throws ValueError if bad format.
+
+    """
     return long(value.replace(get_group_format(locale), ""))
 
 def parse_decimal(value, locale=None):
-    """
-    Takes localized decimal string and returns a float
-    (or throws ValueError if bad format)
-    """
+    """Take localized decimal string and return a float.
 
+    Throws ValueError if bad format.
+
+    """
     value = value.replace(get_group_format(locale), "")
     value = value.replace(get_decimal_format(locale), ".")
     return float(value)
 
-def get_date_format(format, locale=None):
 
+def get_date_format(format, locale=None):
+    """Get localized date format."""
     formats = get(locale, "dateFormats", {})
     return formats.get(format, None)
 
+
 def format_date(dt, format="medium", locale=None,
         time_format="", date_format=""):
-    """
-    Returns formatted date value.
+    """Get formatted date value.
 
     format can be "full", "long", "medium" or "short".
     To have complete control over formatting,
@@ -186,36 +185,31 @@
     @type dt: datetime.datetime
 
     @param format: format("full", "long", "medium", "short")
-    @type format:string
+    @type format: string
 
-    @param locale: XXX
-    @type locale: XXX
+    @param locale: the locale
+    @type locale: string
 
     @param time_format: standard time formatting string, e.g. %H:%M
-    @type time_format:string
+    @type time_format:s tring
 
     @param time_format: date formatting template string.
     Template variables include standard date formatting string like %d or %Y
     plus a few locale-specific names:
     %%(abbrmonthname)s, %%(dayname)s, %%(abbrmonthname)s and %%(monthname)s.
-    @type time_format:string
-    """
-    if date_format:
-        pattern = date_format
-    else:
-        pattern = get_date_format(format, locale)
+    @type time_format: string
 
-    if not pattern:return str(dt)
-
-    month = dt.month-1
+    """
+    pattern = date_format or get_date_format(format, locale)
+    if not pattern:
+        return str(dt)
+    month = dt.month - 1
     weekday = dt.weekday()
-
-    # becase strftime() accepts str only but not unicode
+    # becasue strftime() accepts str only but not unicode,
     # we encode string to utf-8 and then decode back
-    date_str = dt.strftime(pattern.encode('utf8')+time_format)
-    return date_str.decode('utf8') % {
-        'monthname':get_month_names(locale)[month],
-        'abbrmonthname':get_abbr_month_names(locale)[month],
-        'dayname':get_weekday_names(locale)[weekday],
-        'abbrdayname':get_abbr_weekday_names(locale)[weekday],
-    }
+    date_str = dt.strftime(pattern.encode('utf8') + time_format)
+    return date_str.decode('utf8') % dict(
+        monthname=get_month_names(locale)[month],
+        abbrmonthname=get_abbr_month_names(locale)[month],
+        dayname=get_weekday_names(locale)[weekday],
+        abbrdayname=get_abbr_weekday_names(locale)[weekday])
Index: turbogears/errorhandling.py
===================================================================
--- turbogears/errorhandling.py	(revision 4755)
+++ turbogears/errorhandling.py	(working copy)
@@ -18,6 +18,7 @@
 
     Error handler is a function registered via register_handler or if no
     such decorator was applied, the method triggering the error.
+
     """
 dispatch_error = generic(MultiorderGenericFunction)(dispatch_error)
 
@@ -27,6 +28,7 @@
 
     Any method declaring tg_errors parameter is considered an implicitly
     declared error handler.
+
     """
     error_handler(tg_source)(tg_source)
     return dispatch_error(controller, tg_source, tg_errors, tg_exceptions,
@@ -41,6 +43,7 @@
 
     Any method declaring tg_exceptions parameter is considered an
     implicitly declared exception handler.
+
     """
     exception_handler(tg_source)(tg_source)
     return dispatch_error(controller, tg_source, tg_errors, tg_exceptions,
@@ -53,14 +56,18 @@
     """Construct a signature isomorphic to dispatch_error.
 
     The actual handler will receive only arguments explicitly
-    declared.
+    declared, and a possible tg_format parameter.
+
     """
-    def adaptor(controller, tg_source, tg_errors, tg_exceptions, *args, **kw):
+    def adaptor(controller, tg_source,
+            tg_errors, tg_exceptions, *args, **kw):
+        tg_format = kw.pop('tg_format', None)
         args, kw = inject_args(func, {"tg_source":tg_source,
-                                      "tg_errors":tg_errors,
-                                      "tg_exceptions":tg_exceptions},
-                               args, kw, 1)
+            "tg_errors":tg_errors, "tg_exceptions":tg_exceptions},
+                args, kw, 1)
         args, kw = adapt_call(func, args, kw, 1)
+        if tg_format is not None:
+            kw['tg_format'] = tg_format
         return func(controller, *args, **kw)
     return adaptor
 
@@ -79,6 +86,8 @@
         else:
             exc_type, exc_value, exc_trace = sys.exc_info()
             remove_keys(kw, ("tg_source", "tg_errors", "tg_exceptions"))
+            if 'tg_format' in cherrypy.request.params:
+                kw['tg_format'] = 'json'
             if getattr(cherrypy.request, "in_transaction", None):
                 restart_transaction(1)
             try:
@@ -101,6 +110,8 @@
             return self.validation_error(func.__name__, kw, errors)
         else:
             remove_keys(kw, ("tg_source", "tg_errors", "tg_exceptions"))
+            if 'tg_format' in cherrypy.request.params:
+                kw['tg_format'] = 'json'
             try:
                 return dispatch_error(self, func, errors, None, *args, **kw)
             except NoApplicableMethods:
@@ -119,6 +130,7 @@
     single method.
 
     register_handler decorator is an invariant.
+
     """
     def register(func):
         when = "func_eq(tg_source, func)"
Index: turbogears/toolbox/widgets.kid
===================================================================
--- turbogears/toolbox/widgets.kid	(revision 4755)
+++ turbogears/toolbox/widgets.kid	(working copy)
@@ -34,19 +34,26 @@
     <div id="top_background">
         <div id="top">
             <h1>
-                <a href="/">Toolbox</a> &#x00BB; 
+                <a href="/">Toolbox</a> &#x00BB;
                 <a href="index" py:strip="not viewing_one">Widget Browser</a>
                 <span py:if="viewing_one" py:strip="1">&#x00BB; ${descs[0].name}</span>
             </h1>
         </div>
     </div>
 
-    <div py:strip="1" py:for="js in widget_js_bodytop">${js.display()}</div>
+    <div py:strip="1" py:for="js in widget_js_bodytop" py:replace="js.display()"/>
 
-    <center>
-    <div id="main_content" style="width:500px">
+    <ul id="toc">
+        <li py:for="widgetdesc in descs">
+            <a href="#${widgetdesc.full_class_name}" py:content="widgetdesc.name"/>
+        </li>
+    </ul>
 
+    <center style="margin-right:165px;">
+    <div id="main_content" style="width:555px;">
+
         <div py:for="widgetdesc in descs">
+            <a name="${widgetdesc.full_class_name}"/>
             <h3 py:content="widgetdesc.name" />
             <div class="widgetclass" py:content="widgetdesc.full_class_name" />
             <div class="tabber" id="wb_tabber_${widgetdesc.full_class_name}">
@@ -86,6 +93,6 @@
 
     </div>
     </center>
-    <div py:strip="1" py:for="js in widget_js_bodybottom">${js.display()}</div>
+    <div py:strip="1" py:for="js in widget_js_bodybottom" py:replace="js.display()"/>
 </body>
 </html>
Index: turbogears/static/css/toolbox.css
===================================================================
--- turbogears/static/css/toolbox.css	(revision 4755)
+++ turbogears/static/css/toolbox.css	(working copy)
@@ -1,54 +1,40 @@
-body { margin:0;padding:0;
-      font-family:verdana,sans-serif;
-      font-size:12px; 
-       margin-bottom:50px;
-      }
-#top_background{
-          background-image:url('/tg_static/images/top_bg.png');
-          background-repeat:repeat-x;
-      }
-#top {
-        height:100px;
-        width:100%;
-        background-image:url('/tg_static/images/top.png');
-        background-repeat:no-repeat;
-        background-position:top right;
-     }
-#top h1 { font-size:22px;color:#fff;font-weight:100;margin:0;padding:0;
-          margin-left:20px;padding-top:8px;}
-#top h1 a {color:#fff}
-h1,h2,h3,h4,h5 {color:#1F76BD}
+body {margin:0;padding:0;margin-bottom:50px;
+font-family:verdana,sans-serif;font-size:12px;}
+
+#top_background{background-repeat:repeat-x;
+background-image:url('/tg_static/images/top_bg.png');}
+#top {height:100px;width:100%;
+background-repeat:no-repeat;background-position:top right;
+background-image:url('/tg_static/images/top.png');}
+#top h1 {font-size:22px;color:#fff;font-weight:100;
+margin:0;padding:0;margin-left:20px;padding-top:8px;}
+#top h1 a {color:#fff;}
+
+h1,h2,h3,h4,h5 {color:#1F76BD;}
 h2 {margin-top:0;padding-top:0}
-#main_content {text-align:left;width:750px}
+
+#main_content {text-align:left;width:750px;}
 #main_content a {color:#1F76BD;}
-#main_content #tools { border-top:1px solid #1F76BD}
-#main_content #tools h4 { padding-bottom:3px;margin-bottom:3px}
-#left_col { width:229px;}
+#main_content #tools {border-top:1px solid #1F76BD;}
+#main_content #tools h4 {padding-bottom:3px;margin-bottom:3px;}
+
+ul#toc {position:absolute;right:0;list-style:none;
+margin:0 12px; padding: 4px;
+background-color:#eee;border: 1px solid #999;z-index:2;}
+
+#left_col {width:229px;}
 #left_col a {color:#1F76BD;}
-button { background-color:#1F76BD;
-         color:#fff;
-         margin-left:4px;
-         text-align:center;
-       }
-#under_the_hood
-{
-    width:100%;
-    text-align:center;
-    position:absolute;bottom:0px;
-}
 
-.disabled, .disabled h4 {
-    color: grey !important;
-}
+button {background-color:#1F76BD;color:#fff;
+margin-left:4px;text-align:center;}
 
-dl.param_list dd {
-    float: left;
-    width: 110px;
-    text-align: right;
-    font-weight: bold;
-}
-dl.param_list dt {
-    margin-left: 160px;
-}
+#under_the_hood {width:100%;text-align:center;
+position:absolute;bottom:0px;}
 
+.disabled, .disabled h4 {color:grey !important;}
 
+dl.param_list dd {float:left;width:110px;
+text-align:right;font-weight:bold;}
+dl.param_list dt {margin-left:160px;}
+
+input {margin:2px;}
Index: turbogears/controllers.py
===================================================================
--- turbogears/controllers.py	(revision 4755)
+++ turbogears/controllers.py	(working copy)
@@ -28,14 +28,13 @@
                     })
     # support for mysql/sqlite/etc here
 
+
 def _process_output(output, template, format, content_type,
         mapping, fragment=False):
-    """
-    Produces final output form from the data returned from a
-    controller method.
+    """Produce final output form from data returned from a controller method.
 
-    See the expose() arguments for more info in theses ones since
-    they are the same.
+    See the expose() arguments for more info since they are the same.
+
     """
     if isinstance(output, dict):
         from turbogears.widgets import js_location
@@ -75,46 +74,49 @@
                             js[js_location.head].add(script)
         output.update(include_widgets)
         output["tg_css"] = css
-        #output.update([("tg_js_%s" % str(l), js[l]) for l in js_location])
-        for l in iter(js_location):
-            output["tg_js_%s" % str(l)] = js[l]
+        for location in iter(js_location):
+            output["tg_js_%s" % str(location)] = js[location]
 
         tg_flash = _get_flash()
         if not tg_flash == None:
             output["tg_flash"] = tg_flash
+
+        headers = {'Content-Type': content_type}
         output = view.render(output, template=template, format=format,
-                    mapping=mapping, content_type=content_type,
+                    mapping=mapping, headers=headers,
                     fragment=fragment)
+        content_type = headers['Content-Type']
+
+    if content_type:
+        response.headers["Content-Type"] = content_type
     else:
-        if content_type:
-            cherrypy.response.headers["Content-Type"] = content_type
+        content_type = response.headers.get("Content-Type", 'text/plain')
 
-    # fix the Safari XMLHttpRequest encoding problem
-    try:
-        contentType = cherrypy.response.headers["Content-Type"]
-        ua = cherrypy.request.headers["User-Agent"]
-    except KeyError:
-        return output
-    if not contentType.startswith("text/"):
-        return output
-    ua = view.UserAgent(ua)
-    enc = tg_util.get_template_encoding_default()
-    if ua.browser == "safari":
-        if isinstance(output, str):
-            output = output.decode(enc)
-        elif isinstance(output, types.GeneratorType):
-            output = "".join(output)
+    if content_type.startswith("text/"):
+        enc = tg_util.get_template_encoding_default()
+        # fix the Safari XMLHttpRequest encoding problem
+        try:
+            ua = request.headers["User-Agent"]
+        except KeyError:
+            return output
+        ua = view.UserAgent(ua)
+        if ua.browser == "safari":
+            if isinstance(output, str):
+                output = output.decode(enc)
+            elif isinstance(output, types.GeneratorType):
+                output = "".join(output)
+            output = unicodechars.sub(
+                lambda m: "&#x%x;" % ord(m.group(1)), output).encode("ascii")
+        if isinstance(output, unicode):
+            output = output.encode(enc)
 
-        output = unicodechars.sub(
-            lambda m: "&#x%x;" % ord(m.group(1)), output).encode("ascii")
-
-    if isinstance(output, unicode):
-        output = output.encode(enc)
     return output
 
+
 class BadFormatError(Exception):
     """Output-format exception."""
 
+
 def validate(form=None, validators=None,
              failsafe_schema=errorhandling.FailsafeSchema.none,
              failsafe_values=None, state_factory=None):
@@ -204,6 +206,7 @@
         return validate
     return weak_signature_decorator(entangle)
 
+
 class CustomDispatch(functions.GenericFunction):
 
     def combine(self, cases):
@@ -219,6 +222,7 @@
                     return y[1]
         return primary
 
+
 def _add_rule(_expose, found_default, as_format, accept_format, template,
               rulefunc):
     if as_format == "default":
@@ -230,18 +234,17 @@
                 as_format = template[:colon]
         else:
             found_default = True
-    ruleparts = []
-    ruleparts.append('kw.get("tg_format", "default") == "%s"'
-                % as_format)
+    ruleparts = ['kw.get("tg_format", "default") == "%s"' % as_format]
     if accept_format:
-        ruleparts.append('(accept == "%s" and kw.get("tg_format", '
-                '"default") == "default")' % accept_format)
+        ruleparts.append('(accept == "%s" and kw.get("tg_format"'
+            ', "default") == "default")' % accept_format)
     rule = " or ".join(ruleparts)
     log.debug("Generated rule %s", rule)
     _expose.when(rule)(rulefunc)
 
     return found_default
 
+
 def _build_rules(func):
     def _expose(func, accept, allow_json, *args, **kw):
         pass
@@ -249,15 +252,13 @@
 
     if func._allow_json:
         log.debug("Adding allow_json rule: "
-            'allow_json and '
-            '(kw.get("tg_format", None) == "json" or accept '
-            '=="text/javascript")')
-        _expose.when('allow_json '
-            'and (kw.get("tg_format", None) == "json" or accept'
-            ' =="text/javascript")')(
-            lambda _func, accept, allow_json,
-                *args, **kw: _execute_func(
-                    _func, "json", None, None, None, False, args, kw))
+            'allow_json and (kw.get("tg_format", None) == "json"'
+            ' or accept in ("application/json", "text/javascript"))')
+        _expose.when('allow_json and (kw.get("tg_format", None) == "json"'
+            ' or accept in ("application/json", "text/javascript"))')(
+            lambda _func, accept, allow_json, *args, **kw:
+                _execute_func(_func, "json", "json", "application/json",
+                    None, False, args, kw))
 
     found_default = False
     for ruleinfo in func._ruleinfo:
@@ -265,6 +266,7 @@
 
     func._expose = _expose
 
+
 def expose(template=None, validators=None, allow_json=None, html=None,
            format=None, content_type=None, inputform=None, fragment=False,
            as_format="default", mapping=None, accept_format=None):
@@ -290,8 +292,8 @@
     parameter in a request will choose the options for that expose
     decorator. Similarly, accept_format will watch for matching
     Accept headers. You can also use both. expose("json", as_format="json",
-    accept_format="text/javascript") will choose JSON output for either
-    case: tg_format=json as a parameter or Accept: text/javascript as a
+    accept_format="application/json") will choose JSON output for either
+    case: tg_format=json as a parameter or Accept: application/json as a
     request header.
 
     Passing allow_json=True to an expose decorator
@@ -332,6 +334,7 @@
             applied to that arg
     @keyparam inputform deprecated. A form object that generates the
             input to this method
+
     """
     if html:
         template = html
@@ -366,18 +369,16 @@
                 return output
             func.exposed = True
             func._ruleinfo = []
-            allow_json_from_config = config.get(
-                                        "tg.allow_json", False)
-            func._allow_json = allow_json_from_config
+            allow_json_from_config = config.get("tg.allow_json", False)
+            func._allow_json = allow_json_from_config or template == 'json'
         else:
             expose = lambda func, *args, **kw: func(*args, **kw)
 
-        func._ruleinfo.insert(0, dict(as_format = as_format,
-            accept_format = accept_format, template = template,
-            rulefunc = lambda _func, accept, allow_json,
-                    *args, **kw:
-                    _execute_func(_func, template, format, content_type,
-                                mapping, fragment, args, kw)))
+        func._ruleinfo.insert(0, dict(as_format=as_format,
+            accept_format=accept_format, template=template,
+            rulefunc = lambda _func, accept, allow_json, *args, **kw:
+                _execute_func(_func, template, format, content_type,
+                    mapping, fragment, args, kw)))
 
         if allow_json:
             func._allow_json = True
@@ -394,6 +395,7 @@
         return expose
     return weak_signature_decorator(entangle)
 
+
 def _execute_func(func, template, format, content_type, mapping, fragment, args, kw):
     """Call controller method and process it's output."""
     if config.get("tg.strict_parameters", False):
@@ -420,11 +422,14 @@
         template = func.__module__[:func.__module__.rfind('.')]+template
     return _process_output(output, template, format, content_type, mapping, fragment)
 
+
 def flash(message):
     """Set a message to be displayed in the browser on next page display."""
-    cherrypy.response.simple_cookie['tg_flash'] = tg_util.to_utf8(message)
+    message = tg_util.quote_cookie(tg_util.to_utf8(message))
+    cherrypy.response.simple_cookie['tg_flash'] = message
     cherrypy.response.simple_cookie['tg_flash']['path'] = '/'
 
+
 def _get_flash():
     """Retrieve the flash message (if one is set), clearing the message."""
     request_cookie = cherrypy.request.simple_cookie
@@ -448,21 +453,25 @@
     else:
         message = None
     if message:
-        message = unicode(message, 'utf-8')
+        message = unicode(tg_util.unquote_cookie(message), 'utf-8')
     return message
 
+
 class Controller(object):
     """Base class for a web application's controller.
 
     Currently, this provides positional parameters functionality
     via a standard default method.
+
     """
 
+
 class RootController(Controller):
     """Base class for the root of a web application.
 
     Your web application should have one of these. The root of
     your application is used to compute URLs used by your app.
+
     """
     is_app_root = True
 
@@ -496,6 +505,7 @@
 
 Root = RootController
 
+
 def url(tgpath, tgparams=None, **kw):
     """Computes URLs.
 
@@ -510,6 +520,7 @@
 
     Values which are a list or a tuple are used to create multiple
     key-value pairs.
+
     """
     if not isinstance(tgpath, basestring):
         tgpath = "/".join(list(tgpath))
@@ -546,6 +557,7 @@
         result += "?" + "&".join(args)
     return result
 
+
 def check_app_root():
     """Sets cherrypy.request.app_root if needed."""
     if hasattr(cherrypy.request, "app_root"):
@@ -575,16 +587,18 @@
         app_root = app_root[:-1]
     cherrypy.request.app_root = app_root
 
+
 def redirect(redirect_path, redirect_params=None, **kw):
-    """
-    Redirect (via cherrypy.HTTPRedirect).
+    """Redirect (via cherrypy.HTTPRedirect).
+
     Raises the exception instead of returning it, this to allow
     users to both call it as a function or to raise it as an exception.
+
     """
     raise cherrypy.HTTPRedirect(
                     url(tgpath=redirect_path, tgparams=redirect_params, **kw))
 
+
 __all__ = ["expose", "validate", "redirect", "flash",
            "Root", "RootController", "Controller",
-           "error_handler", "exception_handler",
-          ]
+           "error_handler", "exception_handler"]
Index: turbogears/tests/test_expose.py
===================================================================
--- turbogears/tests/test_expose.py	(revision 4755)
+++ turbogears/tests/test_expose.py	(working copy)
@@ -13,7 +13,7 @@
         return dict(title="Foobar", mybool=False, someval="foo")
 
     [expose("turbogears.tests.simple")]
-    [expose("json", accept_format = "text/javascript", as_format="json")]
+    [expose("json", accept_format = "application/json", as_format="json")]
     [expose('cheetah:turbogears.tests.textfmt', accept_format="text/plain")]
     def with_json_via_accept(self):
         return dict(title="Foobar", mybool=False, someval="foo")
@@ -34,7 +34,7 @@
 def test_gettingjsonviaaccept():
     cherrypy.root = ExposeRoot()
     create_request("/with_json_via_accept",
-            headers=dict(Accept="text/javascript"))
+            headers=dict(Accept="application/json"))
     body = cherrypy.response.body[0]
     assert '"title": "Foobar"' in body
 
@@ -59,15 +59,15 @@
             return dict(title="Foobar", mybool=False, someval="niggles")
 
     cherrypy.root = NewRoot()
-    create_request("/test", headers= dict(accept="text/javascript"))
+    create_request("/test", headers= dict(accept="application/json"))
     body = cherrypy.response.body[0]
     values = simplejson.loads(body)
     assert values == dict(title="Foobar", mybool=False, someval="niggles",
         tg_flash=None)
-    assert cherrypy.response.headers["Content-Type"] == "text/javascript"
+    assert cherrypy.response.headers["Content-Type"] == "application/json"
     create_request("/test?tg_format=json")
     body = cherrypy.response.body[0]
     values = simplejson.loads(body)
     assert values == dict(title="Foobar", mybool=False, someval="niggles",
         tg_flash=None)
-    assert cherrypy.response.headers["Content-Type"] == "text/javascript"
+    assert cherrypy.response.headers["Content-Type"] == "application/json"
Index: turbogears/tests/test_controllers.py
===================================================================
--- turbogears/tests/test_controllers.py	(revision 4755)
+++ turbogears/tests/test_controllers.py	(working copy)
@@ -74,8 +74,9 @@
     istrue = error_handler(validation_error_handler)(istrue)
 
     [expose()]
-    def callsanother(self):
-        return self.istrue(True)
+    [validate(validators={'value': validators.StringBoolean()})]
+    def indirectistrue(self, value):
+        return self.istrue(str(value))
 
     [expose(format="json", html="turbogears.tests.simple")]
     def returnjson(self):
@@ -91,6 +92,19 @@
     def impliedjson(self):
         return dict(title="Blah")
 
+    [expose('json')]
+    def explicitjson(self):
+        return dict(title="Blub")
+
+    [expose(html="turbogears.tests.simple", allow_json=True)]
+    def jsonerror_handler(self):
+        return dict(someval="errors")
+
+    [expose(allow_json=True)]
+    def jsonerror(self):
+        raise ValueError
+    jsonerror = exception_handler(jsonerror_handler)(jsonerror)
+
     [expose(content_type="xml/atom")]
     def contenttype(self):
         return "Foobar"
@@ -152,6 +166,11 @@
         redirect("/flash_redirected?tg_format=json")
 
     [expose(html="turbogears.tests.simple", allow_json=True)]
+    def flash_redirect_with_trouble_chars(self):
+        flash(u"$foo, k\xe4se;\tbar!")
+        redirect("/flash_redirected?tg_format=json")
+
+    [expose(html="turbogears.tests.simple", allow_json=True)]
     def flash_redirected(self):
         return dict(title="Foobar", mybool=False, someval="niggles")
 
@@ -229,12 +248,21 @@
         values = simplejson.loads(cherrypy.response.body[0])
         assert values == dict(title="Foobar", mybool=False,
             someval="niggles", tg_flash=None)
-        assert cherrypy.response.headers["Content-Type"] == "text/javascript"
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
 
     def test_implied_json(self):
         testutil.create_request("/impliedjson?tg_format=json")
         assert '"title": "Blah"' in cherrypy.response.body[0]
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
 
+    def test_explicit_json(self):
+        testutil.create_request("/explicitjson")
+        assert '"title": "Blub"' in cherrypy.response.body[0]
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
+        testutil.create_request("/explicitjson?tg_format=json")
+        assert '"title": "Blub"' in cherrypy.response.body[0]
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
+
     def test_allow_json(self):
         testutil.create_request("/allowjson?tg_format=json")
         assert cherrypy.response.headers["Content-Type"] == "text/html"
@@ -249,7 +277,7 @@
                      tg_html="turbogears.tests.simple")
         cherrypy.root = JSONRoot()
         testutil.create_request('/allowjsonconfig?tg_format=json')
-        assert cherrypy.response.headers["Content-Type"] == "text/javascript"
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
         config.update({'tg.allow_json': False})
 
     def test_allow_json_config_false(self):
@@ -265,6 +293,15 @@
         assert cherrypy.response.headers["Content-Type"] == "text/html"
         config.update({'tg.allow_json': False})
 
+    def test_json_error(self):
+        """The error handler should return JSON if requested."""
+        testutil.create_request("/jsonerror")
+        assert cherrypy.response.headers["Content-Type"] == "text/html; charset=utf-8"
+        assert "Paging all errors" in cherrypy.response.body[0]
+        testutil.create_request("/jsonerror?tg_format=json")
+        assert cherrypy.response.headers["Content-Type"] == "application/json"
+        assert '"someval": "errors"' in cherrypy.response.body[0]
+
     def test_invalid_return(self):
         testutil.create_request("/invalid")
         assert cherrypy.response.status.startswith("500")
@@ -371,6 +408,13 @@
         assert len(cherrypy.root.errors) == 1
         assert cherrypy.root.errors.has_key("firstname")
 
+    def test_validation_indirect(self):
+        """Data can be converted and validated if method call is nested"""
+        testutil.create_request("/indirectistrue?value=true")
+        assert cherrypy.root.value is True
+        testutil.create_request("/indirectistrue?value=false")
+        assert cherrypy.root.value is False
+
     def test_validation_with_schema(self):
         """Data can be converted/validated with formencode.Schema instance"""
         testutil.create_request("/save2?submit=send&firstname=Joe&lastname=Doe")
@@ -401,7 +445,7 @@
         """run_with_transaction is called only on topmost exposed method"""
         oldrwt = database.run_with_transaction
         database.run_with_transaction = cherrypy.root.rwt
-        testutil.create_request("/callsanother")
+        testutil.create_request("/indirectistrue?value=true")
         database.run_with_transaction = oldrwt
         assert cherrypy.root.value
         assert cherrypy.root.rwt_called == 1
@@ -432,12 +476,30 @@
         testutil.create_request("/flash_redirect?tg_format=json")
         assert cherrypy.response.status.startswith("302")
         testutil.create_request(cherrypy.response.headers["Location"],
-            headers=dict(Cookie
-                =cherrypy.response.simple_cookie.output(header="").strip()))
+            headers=dict(Cookie=cherrypy.response.simple_cookie.output(
+                header="").strip()))
         import simplejson
         values = simplejson.loads(cherrypy.response.body[0])
         assert values["tg_flash"] == u"redirect \xfcnicode"
 
+    def test_flash_redirect_with_trouble_chars(self):
+        """flash redirect with chars that can cause troubles in cookies"""
+        testutil.create_request("/flash_redirect_with_trouble_chars?tg_format=json")
+        assert cherrypy.response.status.startswith("302")
+        value = cherrypy.response.simple_cookie["tg_flash"].value
+        assert '$' not in value
+        assert ',' not in value and ';' not in value
+        assert ' ' not in value and '\t' not in value
+        assert 'foo' in value and 'bar' in value
+        assert u'k\xe4se'.encode('utf-8') in value
+        assert '!' in value
+        testutil.create_request(cherrypy.response.headers["Location"],
+            headers=dict(Cookie=cherrypy.response.simple_cookie.output(
+                header="").strip()))
+        import simplejson
+        values = simplejson.loads(cherrypy.response.body[0])
+        assert values["tg_flash"] == u"$foo, k\xe4se;\tbar!"
+
     def test_double_flash(self):
         """latest set flash should have precedence"""
         # Here we are calling method that sets a flash message. However flash
Index: turbogears/tests/test_view.py
===================================================================
--- turbogears/tests/test_view.py	(revision 4755)
+++ turbogears/tests/test_view.py	(working copy)
@@ -5,6 +5,32 @@
 
 class TestView(unittest.TestCase):
 
+    def test_cycle(self):
+        oe = view.base.cycle(('odd','even'))
+        assert str(oe) == str(None)
+        assert oe.next() == 'odd'
+        assert str(oe) == 'odd'
+        assert oe.next() == 'even'
+        assert oe.value == 'even'
+        assert oe.next() == 'odd'
+        assert oe.value == 'odd'
+
+    def test_selector(self):
+        assert view.base.selector(False) is None
+        assert view.base.selector(True) == 'selected'
+
+    def test_checker(self):
+        assert view.base.checker(False) is None
+        assert view.base.checker(True) == 'checked'
+
+    def test_ipeek(self):
+        seq = xrange(3, 6)
+        assert view.base.ipeek(seq)
+        assert list(seq) == range(3, 6)
+        seq = xrange(3, 3)
+        assert not view.base.ipeek(seq)
+        assert list(seq) == []
+
     def test_UnicodeValueAppearingInATemplateIsFine(self):
         ustr = u"micro-eXtreme Programming ( Âµ XP): Embedding XP Within Standard Projects"
         info = dict(someval=ustr)
@@ -22,15 +48,18 @@
         filled = str(t)
         assert "groovy" in filled
         assert "html" in filled
-
-        # the following import should not fail, if everything is working correctly.
+        # the following import should not fail, if everything is working correctly:
         import turbogears.tests.simple
 
     def test_default_output_encoding(self):
         info = dict(someval="someval")
+        template = "turbogears.tests.simple"
+        headers = {}
         # default encoding is utf-8
-        val = view.render(info, template="turbogears.tests.simple")
-        assert 'utf-8' in view.cherrypy.response.headers["Content-Type"]
-        config.update({'tg.defaultview':'kid', 'kid.encoding':'iso-8859-1'})
-        val = view.render(info, template="turbogears.tests.simple")
-        assert 'iso-8859-1' in view.cherrypy.response.headers["Content-Type"]
+        val = view.render(info, template, headers=headers)
+        assert headers.get('Content-Type') == 'text/html; charset=utf-8'
+        # encoding can be changed and will be added to existing content type
+        config.update({'tg.defaultview':'kid', 'kid.encoding': 'iso-8859-1'})
+        headers['Content-Type'] = 'text/html'
+        val = view.render(info, template, headers=headers)
+        assert headers.get('Content-Type') == 'text/html; charset=iso-8859-1'
Index: turbogears/qstemplates/quickstart/+package+/config/app.cfg_tmpl
===================================================================
--- turbogears/qstemplates/quickstart/+package+/config/app.cfg_tmpl	(revision 4755)
+++ turbogears/qstemplates/quickstart/+package+/config/app.cfg_tmpl	(working copy)
@@ -179,7 +179,8 @@
 # compress the data sends to the web browser
 # [/]
 # gzip_filter.on = True
-# gzip_filter.mime_types = ["application/x-javascript", "text/javascript", "text/html", "text/css", "text/plain"]
+# gzip_filter.mime_types = ["application/json", "application/x-javascript",
+#     "text/javascript", "text/html", "text/css", "text/plain"]
 
 [/static]
 static_filter.on = True
Index: turbogears/qstemplates/quickstart/+package+/controllers.py_tmpl
===================================================================
--- turbogears/qstemplates/quickstart/+package+/controllers.py_tmpl	(revision 4755)
+++ turbogears/qstemplates/quickstart/+package+/controllers.py_tmpl	(working copy)
@@ -26,7 +26,7 @@
 
         if not identity.current.anonymous and identity.was_login_attempted() \
                 and not identity.get_identity_errors():
-            raise redirect(tg.url(forward_url or previous_url or '/', kw))
+            redirect(tg.url(forward_url or previous_url or '/', kw))
 
         forward_url = None
         previous_url = request.path
@@ -48,5 +48,5 @@
     ${b}expose()${e}
     def logout(self):
         identity.current.logout()
-        raise redirect("/")
+        redirect("/")
 #end if
Index: turbogears/qstemplates/quickstartbig/+package+/controllers/root.py_tmpl
===================================================================
--- turbogears/qstemplates/quickstartbig/+package+/controllers/root.py_tmpl	(revision 4755)
+++ turbogears/qstemplates/quickstartbig/+package+/controllers/root.py_tmpl	(working copy)
@@ -26,7 +26,7 @@
 
         if not identity.current.anonymous and identity.was_login_attempted() \
                 and not identity.get_identity_errors():
-            raise redirect(tg.url(forward_url or previous_url or '/', kw))
+            redirect(tg.url(forward_url or previous_url or '/', kw))
 
         forward_url = None
         previous_url = request.path
@@ -48,5 +48,5 @@
     ${b}expose()${e}
     def logout(self):
         identity.current.logout()
-        raise redirect("/")
+        redirect("/")
 #end if
Index: turbogears/feed/atom1_0.kid
===================================================================
--- turbogears/feed/atom1_0.kid	(revision 4755)
+++ turbogears/feed/atom1_0.kid	(working copy)
@@ -9,6 +9,8 @@
   <updated py:if="hasattr(self, 'updated')" py:content="updated">updated</updated>
   <author py:if="hasattr(self, 'author')">
     <name py:content="author['name']">name</name>
+    <email py:if="author.has_key('email')" py:content="author['email']">email</email>
+    <uri py:if="author.has_key('uri')" py:content="author['uri']">uri</uri>
   </author>
   <link py:if="hasattr(self, 'href')" rel="self" href="${href}" />
   <icon py:if="hasattr(self, 'icon')" py:content="icon">icon</icon>
@@ -23,7 +25,9 @@
     <link py:if="entry.has_key('link')" rel="alternate" href="${entry['link']}" />
     <published py:if="entry.has_key('published')" py:content="entry['published']">published</published>
     <author py:if="entry.has_key('author')">
-        <name py:content="author['name']">name</name>
+        <name py:content="entry['author']['name']">name</name>
+        <email py:if="entry['author'].has_key('email')" py:content="entry['author']['email']">email</email>
+        <uri py:if="entry['author'].has_key('uri')" py:content="entry['author']['uri']">uri</uri>
     </author>
     <content py:if="entry.has_key('content')" py:content="entry['content']">content</content>
     <summary py:if="entry.has_key('summary')" py:content="entry['summary']">summary</summary>
Index: turbogears/util.py
===================================================================
--- turbogears/util.py	(revision 4755)
+++ turbogears/util.py	(working copy)
@@ -1,50 +1,131 @@
+"""The TurboGears utility module."""
+
 import os
 import sys
 import re
+import logging
+import warnings
 import htmlentitydefs
 from inspect import getargspec, getargvalues
 from itertools import izip, islice, chain, imap
 from operator import isSequenceType
+from urllib import quote, unquote
 
 import pkg_resources
-import setuptools
 
 from cherrypy import request
+
 from turbogears.decorator import decorator
 from turbogears import config
-import logging
 
-# This Enum implementation is from the Python Cookbook and is
-# written by Zoran Isailovski:
-# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/413486
 
+def deprecated(message=None):
+    """Decorator which can be used to mark functions as deprecated.
+
+    It will result in a warning being emmitted when the function is used.
+
+    Inspired by http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/391367
+
+    """
+    def decorate(func):
+        if not decorate.message:
+            decorate.message = \
+                "Call to deprecated function %s." % func.__name__
+        def newFunc(*args, **kwargs):
+            warnings.warn(decorate.message, category=DeprecationWarning,
+                stacklevel = 2)
+            return func(*args, **kwargs)
+        try:
+            newFunc.__name__ = func.__name__
+        except TypeError: # not writable in Python 2.3
+            pass
+        newFunc.__doc__ = func.__doc__
+        newFunc.__dict__.update(func.__dict__)
+        return newFunc
+    decorate.message = message
+    return decorate
+
+
+class Bunch(dict):
+    """Simple but handy collector of a bunch of named stuff."""
+
+    def __repr__(self):
+        keys = self.keys()
+        keys.sort()
+        args = ', '.join(['%s=%r' % (key, self[key]) for key in keys])
+        return '%s(%s)' % (self.__class__.__name__, args)
+
+    def __getattr__(self, name):
+        try:
+            return self[name]
+        except KeyError:
+            raise AttributeError(name)
+
+    __setattr__ = dict.__setitem__
+
+    def __delattr__(self, name):
+        try:
+            del self[name]
+        except KeyError:
+            raise AttributeError(name)
+
+
+class DictObj(Bunch):
+
+    def __init__(self, *args, **kw):
+        super(DictObj, self).__init__(*args, **kw)
+    __init__ = deprecated(
+        "Use Bunch instead of DictObj and DictWrapper.")(__init__)
+
+DictWrapper = DictObj
+
+
 def Enum(*names):
-    ##assert names, "Empty enums are not supported" # <- Don't like empty enums? Uncomment!
+    """True immutable symbolic enumeration with qualified value access.
 
+    Written by Zoran Isailovski:
+    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/413486
+
+    """
+
+    # Uncomment the following line if you don't like empty enums.
+    # assert names, "Empty enums are not supported"
+
     class EnumClass(object):
         __slots__ = names
-        def __iter__(self):          return iter(constants)
-        def __len__(self):            return len(constants)
-        def __getitem__(self, i):  return constants[i]
-        def __repr__(self):          return 'Enum' + str(names)
-        def __str__(self):            return 'enum ' + str(constants)
+        def __iter__(self):
+            return iter(constants)
+        def __len__(self):
+            return len(constants)
+        def __getitem__(self, i):
+            return constants[i]
+        def __repr__(self):
+            return 'Enum' + str(names)
+        def __str__(self):
+            return 'enum ' + str(constants)
 
     enumType = EnumClass()
 
     class EnumValue(object):
         __slots__ = ('__value')
-        def __init__(self, value): self.__value = value
+        def __init__(self, value):
+            self.__value = value
         Value = property(lambda self: self.__value)
         EnumType = property(lambda self: enumType)
-        def __hash__(self):          return hash(self.__value)
+        def __hash__(self):
+            return hash(self.__value)
         def __cmp__(self, other):
             # C fans might want to remove the following assertion
             # to make all enums comparable by ordinal value {;))
-            assert self.EnumType is other.EnumType, "Only values from the same enum are comparable"
+            assert self.EnumType is other.EnumType, \
+                "Only values from the same enum are comparable"
             return cmp(self.__value, other.__value)
-        def __invert__(self):        return constants[maximum - self.__value]
-        def __nonzero__(self):      return bool(self.__value)
-        def __repr__(self):          return str(names[self.__value])
+        def __invert__(self):
+            return constants[maximum - self.__value]
+        def __nonzero__(self):
+            return bool(self.__value)
+        def __repr__(self):
+            return str(names[self.__value])
 
     maximum = len(names) - 1
     constants = [None] * len(names)
@@ -55,6 +136,7 @@
     constants = tuple(constants)
     return enumType
 
+
 class setlike(list):
     """Set preserving item order."""
 
@@ -66,73 +148,71 @@
         for item in iterable:
             self.add(item)
 
+
 def get_project_meta(name):
+    """Get egg-info file with that name in the current project."""
     for dirname in os.listdir("./"):
         if dirname.lower().endswith("egg-info"):
             fname = os.path.join(dirname, name)
             return fname
 
+
 def get_project_config():
-    """Tries to select appropriate project configuration file."""
+    """Try to select appropriate project configuration file."""
+    return os.path.exists('setup.py') and 'dev.cfg' or 'prod.cfg'
 
-    config = None
-    if os.path.exists("setup.py"):
-        config = "dev.cfg"
-    else:
-        config = "prod.cfg"
-    return config
 
 def load_project_config(configfile=None):
-    """Tries to update the config, loading project settings from the config
-    file specified.  If config is C{None} uses L{get_project_config} to locate
-    one.
+    """Try to update the project settings from the config file specified.
+
+    If configfile is C{None}, uses L{get_project_config} to locate one.
+
     """
     if configfile is None:
         configfile = get_project_config()
     if not os.path.isfile(configfile):
-        print 'config file %s not found or is not a file.' % os.path.abspath(configfile)
+        print 'Config file %s not found or is not a file.' % (
+            os.path.abspath(configfile),)
         sys.exit()
     package = get_package_name()
     config.update_config(configfile=configfile,
         modulename = package + ".config")
 
+
 def get_package_name():
     """Try to find out the package name of the current directory."""
     package = config.get("package")
     if package:
         return package
-
     if hasattr(sys, 'argv') and "--egg" in sys.argv:
         projectname = sys.argv[sys.argv.index("--egg")+1]
         egg = pkg_resources.get_distribution(projectname)
         top_level = egg._get_metadata("top_level.txt")
-
     else:
         fname = get_project_meta('top_level.txt')
         top_level = fname and open(fname) or []
-
     for package in top_level:
         package = package.rstrip()
         if package and package != 'locales':
             return package
 
+
 def get_project_name():
     pkg_info = get_project_meta('PKG-INFO')
     if pkg_info:
         name = list(open(pkg_info))[1][6:-1]
         return name.strip()
 
+
 def get_model():
     package_name = get_package_name()
-
     if not package_name:
         return None
-
     package = __import__(package_name, {}, {}, ["model"])
-
     if hasattr(package, "model"):
         return package.model
 
+
 def ensure_sequence(obj):
     """Construct a sequence from object."""
     if obj is None:
@@ -142,28 +222,28 @@
     else:
         return [obj]
 
+
 def to_kw(func, args, kw, start=0):
     """Convert all applicable arguments to keyword arguments."""
     argnames, defaults = getargspec(func)[::3]
     defaults = ensure_sequence(defaults)
     kv_pairs = izip(
-            islice(argnames, start, len(argnames) - len(defaults)),
-            args)
-
+        islice(argnames, start, len(argnames) - len(defaults)), args)
     for k, v in kv_pairs:
         kw[k] = v
-
     return args[len(argnames)-len(defaults)-start:], kw
 
+
 def from_kw(func, args, kw, start=0):
     """Extract named positional arguments from keyword arguments."""
     argnames, defaults = getargspec(func)[::3]
     defaults = ensure_sequence(defaults)
     newargs = [kw.pop(name) for name in islice(argnames, start,
-               len(argnames) - len(defaults)) if name in kw]
+        len(argnames) - len(defaults)) if name in kw]
     newargs.extend(args)
     return newargs, kw
 
+
 def adapt_call(func, args, kw, start=0):
     """Remove excess arguments."""
     argnames, varargs, kwargs, defaults = getargspec(func)
@@ -176,16 +256,16 @@
     else:
         pivot = len(argnames) - len(defaults)
         args = tuple(chain(islice(args, pivot), imap(kw.pop, islice(
-                        argnames, pivot, None)), islice(args, pivot, None)))
+            argnames, pivot, None)), islice(args, pivot, None)))
     return args, kw
 
+
 def call_on_stack(func_name, kw, start=0):
     """Check if a call to function matching pattern is on stack."""
     try:
         frame = sys._getframe(start+1)
     except ValueError:
         return False
-
     while frame.f_back:
         frame = frame.f_back
         if frame.f_code.co_name == func_name:
@@ -193,13 +273,26 @@
             for key in kw.iterkeys():
                 try:
                     if kw[key] != args[key]:
-                        continue
-                except KeyError, TypeError:
-                    continue
-            if key or not args:
+                        break
+                except (KeyError, TypeError):
+                    break
+            else:
                 return True
     return False
 
+
+def remove_keys(dict_, seq):
+    """Gracefully remove keys from dict."""
+    for key in seq:
+        dict_.pop(key, None)
+    return dict_
+
+
+def has_arg(func, argname):
+    """Check whether function has argument."""
+    return argname in getargspec(func)[0]
+
+
 def arg_index(func, argname):
     """Find index of argument as declared for given function."""
     argnames = getargspec(func)[0]
@@ -208,9 +301,6 @@
     else:
         return None
 
-def has_arg(func, argname):
-    """Check whether function has argument."""
-    return argname in getargspec(func)[0]
 
 def inject_arg(func, argname, argval, args, kw, start=0):
     """Insert argument into call."""
@@ -222,20 +312,23 @@
     else:
         pos -= start
         args = tuple(chain(islice(args, pos), (argval,),
-                           islice(args, pos, None)))
+            islice(args, pos, None)))
     return args, kw
 
+
 def inject_args(func, injections, args, kw, start=0):
     """Insert arguments into call."""
     for argname, argval in injections.iteritems():
         args, kw = inject_arg(func, argname, argval, args, kw, start)
     return args, kw
 
+
 def inject_call(func, injections, *args, **kw):
     """Insert arguments and call."""
     args, kw = inject_args(func, injections, args, kw)
     return func(*args, **kw)
 
+
 def bind_args(**add):
     """Call with arguments set to a predefined value."""
     def entagle(func):
@@ -245,17 +338,12 @@
         argnames, varargs, kwargs, defaults = getargspec(func)
         defaults = list(ensure_sequence(defaults))
         defaults = [d for d in defaults if
-                    argnames[-len(defaults) + defaults.index(d)] not in add]
+            argnames[-len(defaults) + defaults.index(d)] not in add]
         argnames = [arg for arg in argnames if arg not in add]
         return decorator(entagle, (argnames, varargs, kwargs, defaults))(func)
 
     return make_decorator
 
-def remove_keys(dict_, seq):
-    """Gracefully remove keys from dict."""
-    for key in seq:
-        dict_.pop(key, None)
-    return dict_
 
 def recursive_update(to_dict, from_dict):
     """Recursively update all dicts in to_dict with values from from_dict."""
@@ -267,6 +355,7 @@
             to_dict[k] = v
     return to_dict
 
+
 def combine_contexts(frames=None, depth=None):
     """Combine contexts (globals, locals) of frames."""
     locals_ = {}
@@ -280,6 +369,7 @@
         globals_.update(frame.f_globals)
     return locals_, globals_
 
+
 def request_available():
     """Check if cherrypy.request is available."""
     try:
@@ -300,14 +390,14 @@
 
 
 def load_class(dottedpath):
-    '''
-    Loads a class from a module in dotted-path notation.
-    Eg: load_class("package.module.class").
+    """Load a class from a module in dotted-path notation.
 
-    Based on recipe 16.3 from "Python Cookbook, 2ed., by Alex Martelli,
+    E.g.: load_class("package.module.class").
+
+    Based on recipe 16.3 from Python Cookbook, 2ed., by Alex Martelli,
     Anna Martelli Ravenscroft, and David Ascher (O'Reilly Media, 2005)
-    0-596-00797-3"
-    '''
+
+    """
     assert dottedpath is not None, "dottedpath must not be None"
     splitted_path = dottedpath.split('.')
     modulename = '.'.join(splitted_path[:-1])
@@ -327,45 +417,89 @@
         return None
     return getattr(module, classname)
 
-class Bunch(dict):
-    __setattr__ = dict.__setitem__
 
-    def __delattr__(self, name):
-        try:
-            del self[name]
-        except KeyError:
-            raise AttributeError(name)
+def parse_http_accept_header(accept):
+    """Parse an HTTP Accept header (RFC 2616) into a sorted list.
 
-    def __getattr__(self, name):
-        try:
-            return self[name]
-        except KeyError:
-            raise AttributeError(name)
+    The quality factors in the header determine the sort order.
+    The values can include possible media-range parameters.
+    This function can also be used for the Accept-Charset,
+    Accept-Encoding and Accept-Language headers.
 
-#XXX: Should issue Deprecation warning?
-DictObj = Bunch
-DictWrapper = Bunch
-
-def parse_http_accept_header(accept):
+    """
+    if accept is None:
+        return []
     items = []
-    if accept is None:
-        return items
-    for item in accept.split(","):
-        pos = item.find(";q=")
-        order = 1
-        if pos > -1:
-            order = float(item[pos+3:].strip())
-            item = item[:pos].strip()
-        items.append((item, order))
+    for item in accept.split(','):
+        params = item.split(';')
+        for i, param in enumerate(params[1:]):
+            param = param.split('=', 1)
+            if param[0].strip() == 'q':
+                try:
+                    q = float(param[1])
+                    if not 0 < q <= 1:
+                        raise ValueError
+                except (IndexError, ValueError):
+                    q = 0
+                else:
+                    item = ';'.join(params[:i+1])
+                break
+        else:
+            q = 1
+        if q:
+            item = item.strip()
+            if item:
+                items.append((item, q))
     items.sort(lambda i1, i2: cmp(i2[1], i1[1]))
-    return [i[0] for i in items]
+    return [item[0] for item in items]
 
-def to_unicode(value):
+
+def simplify_http_accept_header(accept):
+    """Parse an HTTP Accept header (RFC 2616) into a preferred value.
+
+    The quality factors in the header determine the preference.
+    Possible media-range parameters are allowed, but will be ignored.
+    This function can also be used for the Accept-Charset,
+    Accept-Encoding and Accept-Language headers.
+
+    This is similar to parse_http_accept_header(accept)[0], but faster.
+
     """
-    Converts encoded string to unicode string.
+    if accept is None:
+        return None
+    best_item = accept
+    best_q = 0
+    for item in accept.split(','):
+        params = item.split(';')
+        item = params.pop(0)
+        for param in params:
+            param = param.split('=', 1)
+            if param[0].strip() == 'q':
+                try:
+                    q = float(param[1])
+                    if not 0 < q <= 1:
+                        raise ValueError
+                except (IndexError, ValueError):
+                    q = 0
+                break
+        else:
+            q = 1
+        if q > best_q:
+            item = item.strip()
+            if item:
+                best_item = item
+                if q == 1:
+                    break
+                best_q = q
+    return best_item
 
+
+def to_unicode(value):
+    """Convert encoded string to unicode string.
+
     Uses get_template_encoding_default() to guess source string encoding.
     Handles turbogears.i18n.lazystring correctly.
+
     """
     if isinstance(value, str):
         # try to make sure we won't get UnicodeDecodeError from the template
@@ -380,10 +514,14 @@
                 raise ValueError("Non-unicode string: %r" % value)
     return value
 
+
 def to_utf8(value):
-    """Converts a unicode string to utf-8 encoded plain string.
+    """Convert a unicode string to utf-8 encoded plain string.
 
-    Handles turbogears.i18n.lazystring correctly. Does nothing to already encoded string.
+    Handles turbogears.i18n.lazystring correctly.
+
+    Does nothing to already encoded string.
+
     """
     if isinstance(value, str):
         pass
@@ -393,19 +531,36 @@
         value = value.encode('utf-8')
     return value
 
+
+_safe_for_cookie = ''.join(filter(lambda c: c != quote(c)
+    and c not in "$,; \t\f\n\r\v", map(chr, xrange(256))))
+
+def quote_cookie(value):
+    """Escape chars in value that should not be put directly in a cookie."""
+    return quote(value, _safe_for_cookie)
+
+
+def unquote_cookie(value):
+    """Unescape chars in a cookie value, the reverse of quote_cookie(value)."""
+    return unquote(value)
+
+
 def get_template_encoding_default(engine_name=None):
-    """Returns default encoding for template files (Kid, Genshi, etc.)."""
+    """Return default encoding for template files (Kid, Genshi, etc.)."""
     if engine_name is None:
         engine_name = config.get('tg.defaultview', 'kid')
     return config.get('%s.encoding' % engine_name, 'utf-8')
 
+
 def find_precision(value):
-    """
-    Find precision of some arbitrary value.  The main intention for this function
-    is to use it together with turbogears.i18n.format.format_decimal() where one
-    has to inform the precision wanted.  So, use it like this:
+    """Find precision of some arbitrary value.
 
+    The main intention for this function is to use it together with
+    turbogears.i18n.format.format_decimal() where one has to inform
+    the precision wanted. So, use it like this:
+
     format_decimal(some_number, find_precision(some_number))
+
     """
     decimals = ''
     try:
@@ -414,6 +569,7 @@
         pass
     return len(decimals)
 
+
 def copy_if_mutable(value, feedback=False):
     if isinstance(value, dict):
         mutable = True
@@ -428,30 +584,33 @@
     else:
         return value
 
+
 def fixentities(htmltext):
-    # replace HTML character entities with numerical references
-    # note: this won't handle CDATA sections properly
-    def repl(m):
-        entity = htmlentitydefs.entitydefs.get(m.group(1).lower())
+    """Replace HTML character entities with numerical references.
+
+    Note: This won't handle CDATA sections properly.
+
+    """
+    def repl(matchobj):
+        entity = htmlentitydefs.entitydefs.get(matchobj.group(1).lower())
         if not entity:
-            return m.group(0)
+            return matchobj.group(0)
         elif len(entity) == 1:
             if entity in "&<>'\"":
-                return m.group(0)
+                return matchobj.group(0)
             return "&#%d;" % ord(entity)
         else:
             return entity
     return re.sub("&(\w+);?", repl, htmltext)
 
 
-__all__ = ["Enum", "setlike",
+__all__ = ["Bunch", "DictObj", "DictWrapper", "Enum", "setlike",
            "get_package_name", "get_model", "load_project_config",
-           "url", "ensure_sequence", "has_arg",
-           "DictWrapper", "DictObj", "to_kw", "from_kw", "adapt_call",
-           "call_on_stack", "remove_keys",
-           "arg_index", "inject_arg", "inject_args", "bind_args",
-           "recursive_update", "combine_contexts", "request_available",
-           "flatten_sequence", "load_class", "Bunch",
-           "parse_http_accept_header",
-           "to_unicode", "to_utf8", "get_template_encoding_default",
-           "find_precision", "copy_if_mutable"]
+           "ensure_sequence", "has_arg", "to_kw", "from_kw", "adapt_call",
+           "call_on_stack", "remove_keys", "arg_index", "inject_arg",
+           "inject_args", "bind_args", "recursive_update", "combine_contexts",
+           "request_available", "flatten_sequence", "load_class",
+           "parse_http_accept_header", "simplify_http_accept_header",
+           "to_unicode", "to_utf8", "quote_cookie", "unquote_cookie",
+           "get_template_encoding_default", "find_precision",
+           "copy_if_mutable", "deprecated"]
Index: turbogears/widgets/base.py
===================================================================
--- turbogears/widgets/base.py	(revision 4755)
+++ turbogears/widgets/base.py	(working copy)
@@ -201,9 +201,10 @@
         Adjusts the value sent to the template on display.
         """
         if value is None:
-            return self.default
-        else:
-            return value
+            value = self.default
+            if callable(value):
+                value = value()
+        return value
 
     def update_params(self, params):
         """
@@ -580,7 +581,10 @@
     """
 
     template = """
-    <script xmlns:py="http://purl.org/kid/ns#" py:if="not suppress" type="text/javascript" src="$link"/>
+    <span xmlns:py="http://purl.org/kid/ns#" py:strip="True">
+        <script py:if="not suppress" type="text/javascript" src="$link"/>
+        <script py:if="suppress" type="text/javascript"></script>
+    </span>
     """
 
     def update_params(self, p):
Index: turbogears/widgets/tests/test_forms.py
===================================================================
--- turbogears/widgets/tests/test_forms.py	(revision 4755)
+++ turbogears/widgets/tests/test_forms.py	(working copy)
@@ -169,12 +169,16 @@
             widgets.TextField("age")
         ])
     ])
+
+
 class NestedController(controllers.Controller):
+
+    [expose()]
+    [validate(form=nestedform)]
     def checkform(self, foo):
         self.foo = foo
-    checkform = expose()(checkform)
-    checkform = validate(form=nestedform)(checkform)
 
+
 def test_nested_variables():
     cherrypy.request = oldrequest
     newroot = NestedController()
Index: turbogears/widgets/tests/test_widgets.py
===================================================================
--- turbogears/widgets/tests/test_widgets.py	(revision 4755)
+++ turbogears/widgets/tests/test_widgets.py	(working copy)
@@ -51,6 +51,12 @@
     output = textfield.render(format='xhtml')
     assert 'value="ed kowalczyk"' in output
 
+def test_callable_default_value():
+    """Widgets can have a callable default value"""
+    textfield = widgets.TextField("name", default=lambda: "chad taylor")
+    output = textfield.render(format='xhtml')
+    assert 'value="chad taylor"' in output
+
 def test_labeltext():
     "Label text defaults to the capitalized name"
     textfield = widgets.TextField("name")
Index: turbogears/widgets/datagrid.py
===================================================================
--- turbogears/widgets/datagrid.py	(revision 4755)
+++ turbogears/widgets/datagrid.py	(working copy)
@@ -17,7 +17,7 @@
     """Generic widget to present and manipulate data in a grid (tabular) form.
 
     The columns to build the grid from are specified with fields ctor argument
-    which is a list.  Currently an element can be either a two-element tuple or
+    which is a list. Currently an element can be either a two-element tuple or
     instance of DataGrid.Column class. If tuple is used it a Column is then
     build out of it, first element is assumed to be a title and second element -
     field accessor.
@@ -68,13 +68,15 @@
         """Helper class that returns an object's attribute when called.
 
         This allows to access 'dynamic' attributes (properties) as well as
-        simple static ones.
+        simple static ones, and also allows nested access.
         """
         def __init__(self, name):
             assert isinstance(name, str)
             self.name = name
         def __call__(self, obj):
-            return getattr(obj, self.name)
+            for name in self.name.split('.'):
+                obj = getattr(obj, name)
+            return obj
 
     def __init__(self, fields=None, **kw):
         super(DataGrid, self).__init__(**kw)
@@ -141,7 +143,30 @@
                                    (44, "Pablo Martelli", "Brazil")])
 
 class PaginateDataGrid(DataGrid):
+    """A data grid widget that supports the paginate decorator."""
+
     template = "turbogears.widgets.templates.paginate_datagrid"
 
-#TODO: Create PaginateDataGridDesc
-#class PaginateDataGridDesc(CoreWD):
+
+class PaginateDataGridDesc(CoreWD):
+
+    name = "PaginateDataGrid"
+
+    for_widget = DataGridDesc.for_widget
+
+    class Paginate(object):
+        # paginate var mock-up
+        page_count = 5
+        pages = range(1, page_count + 1)
+        limit = 3
+        current_page = page_count // 2
+        href_first = "javascript:alert('This is only a mock-up.')"
+        href_prev = href_next = href_last = href_first
+        get_href = lambda self, page, **kw: self.href_first
+
+    def display(self, *args, **kw):
+        # activate paginate var provider
+        import turbogears.paginate
+        from cherrypy import request
+        request.paginate = self.Paginate()
+        return super(PaginateDataGridDesc, self).display(*args, **kw)
Index: turbogears/widgets/static/autocompletefield.js
===================================================================
--- turbogears/widgets/static/autocompletefield.js	(revision 4755)
+++ turbogears/widgets/static/autocompletefield.js	(working copy)
@@ -340,9 +340,12 @@
 	return s.offsetHeight + getTop(s);
 }
 
+if (typeof getStyle != 'function' && typeof computedStyle == 'function')
+	getStyle = computedStyle; // MochiKit 1.3.1
+
 function getParentOffset(s, offsetType) {
 	var parentOffset=0;
-	while (s && computedStyle(s, 'position') != 'relative') {
+	while (s && getStyle(s, 'position') != 'relative') {
 		parentOffset += s[offsetType];
 		s = s.offsetParent;
 	}
Index: turbogears/widgets/links.py
===================================================================
--- turbogears/widgets/links.py	(revision 4755)
+++ turbogears/widgets/links.py	(working copy)
@@ -55,9 +55,9 @@
     name = "Tabber"
     for_widget = Tabber()
     template = """<div class="tabber">
-        <div class="tabbertab"><h2>Tab 1</h2></div>
-        <div class="tabbertab"><h2>Tab 2</h2></div>
-        <div class="tabbertab"><h2>Tab 3</h2></div>
+        <div class="tabbertab"><h2>Tab 1</h2><p>This is page 1.</p></div>
+        <div class="tabbertab"><h2>Tab 2</h2><p>This is page 2.</p></div>
+        <div class="tabbertab"><h2>Tab 3</h2><p>This is page 3.</p></div>
         </div>"""
 
 class SyntaxHighlighter(Widget):
Index: turbogears/widgets/forms.py
===================================================================
--- turbogears/widgets/forms.py	(revision 4755)
+++ turbogears/widgets/forms.py	(working copy)
@@ -228,6 +228,8 @@
         else:
             if value is None:
                 value = self.default
+                if callable(value):
+                    value = value()
             if self.validator and params["convert"] and not input_submitted:
                 value = self.validator.from_python(value)
         return value
Index: turbogears/widgets/templates/datagrid.kid
===================================================================
--- turbogears/widgets/templates/datagrid.kid	(revision 4755)
+++ turbogears/widgets/templates/datagrid.kid	(working copy)
@@ -1,17 +1,12 @@
-<div xmlns:py="http://purl.org/kid/ns#">
-  <table id="${name}" class="grid" cellpadding="0" cellspacing="1" border="0">
-    <thead py:if="columns">
-      <tr>
-          <th py:for="i, col in enumerate(columns)" class="col_${i}">
-            ${col.title}
-          </th>
-      </tr>
-    </thead>
-    <tr py:for="i, row in enumerate(value)" class="${i%2 and 'odd' or 'even'}">
-      <td py:for="col in columns">
-        ${col.get_field(row)}
-      </td>
-    </tr>
-  </table>
-</div>
-
+<table xmlns:py="http://purl.org/kid/ns#" id="${name}" class="grid" cellpadding="0" cellspacing="1" border="0">
+<thead py:if="columns">
+  <tr>
+    <th py:for="i, col in enumerate(columns)" class="col_${i}" py:content="col.title"/>
+  </tr>
+</thead>
+<tbody>
+  <tr py:for="i, row in enumerate(value)" class="${i%2 and 'odd' or 'even'}">
+    <td py:for="col in columns" align="${col.get_option('align', None)}" py:content="col.get_field(row)"/>
+  </tr>
+</tbody>
+</table>
\ No newline at end of file
Index: turbogears/widgets/templates/paginate_datagrid.kid
===================================================================
--- turbogears/widgets/templates/paginate_datagrid.kid	(revision 4755)
+++ turbogears/widgets/templates/paginate_datagrid.kid	(working copy)
@@ -1,53 +1,30 @@
-<div xmlns:py="http://purl.org/kid/ns#">
-  <table>
-    <tr>
-        <td>
-            <table align="center">
-                <tr>
-                    <td width="50" align="right">
-                        &nbsp;
-                        <span py:if="tg.paginate.href_prev">
-                            <a href="${tg.paginate.href_first}">&lt;&lt;</a>
-                            <a href="${tg.paginate.href_prev}">&lt;</a>
-                        </span>
-                    </td>
-                    <td>
-                        <span py:if="tg.paginate.page_count > 1" py:for="page in tg.paginate.pages">
-                            <span py:if="page == tg.paginate.current_page" py:replace="page"/>
-                            <span py:if="page != tg.paginate.current_page">
-                                <a href="${tg.paginate.get_href(page)}">${page}</a>
-                            </span>
-                        </span>
-                    </td>
-                    <td width="50">
-                        <span py:if="tg.paginate.href_next">
-                            <a href="${tg.paginate.href_next}">&gt;</a>
-                            <a href="${tg.paginate.href_last}">&gt;&gt;</a>
-                        </span>
-                        &nbsp;
-                    </td>
-                    </tr>
-            </table>
-        </td>
-    </tr>
-    <tr>
-        <td>
-          <table id="${name}" class="grid" cellpadding="0" cellspacing="1" border="0">
-            <thead py:if="columns">
-              <th py:for="i, col in enumerate(columns)" class="col_${i}">
-                <a py:if="col.get_option('sortable', False) and getattr(tg, 'paginate', False)"
-                    href="${tg.paginate.get_href(1, col.name, col.get_option('reverse_order', False))}">${col.title}</a>
-                <span py:if="not getattr(tg, 'paginate', False) or not col.get_option('sortable', False)" py:replace="col.title"/>
-              </th>
-            </thead>
-            <tr py:for="i, row in enumerate(value)" class="${i%2 and 'odd' or 'even'}">
-              <td py:for="col in columns">
-                ${col.get_field(row)}
-              </td>
-            </tr>
-          </table>
-        </td>
-    </tr>
-  </table>
-</div>
-
+<table xmlns:py="http://purl.org/kid/ns#" id="${name}"
+  class="grid" cellpadding="0" cellspacing="1" border="0">
+<thead>
+  <tr py:if="getattr(tg, 'paginate', False) and tg.paginate.page_count > 1">
+    <td align="center" colspan="${len(columns) or None}">
+      <a py:strip="not tg.paginate.href_first" href="${tg.paginate.href_first}">&lt;&lt;</a>
+      <a py:strip="not tg.paginate.href_prev" href="${tg.paginate.href_prev}">&lt;</a>
+      &#160;<span py:for="page in tg.paginate.pages" py:strip="True">
+      <a py:strip="page == tg.paginate.current_page"
+        href="${tg.paginate.get_href(page)}" py:content="page"/>
+      </span>&#160;
+      <a py:strip="not tg.paginate.href_next" href="${tg.paginate.href_next}">&gt;</a>
+      <a py:strip="not tg.paginate.href_last" href="${tg.paginate.href_last}">&gt;&gt;</a>
+    </td>
+  </tr>
+  <tr py:if="columns">
+    <th py:for="i, col in enumerate(columns)" class="col_${i}">
+      <a py:strip="not getattr(tg, 'paginate', False) or not col.get_option('sortable', False)"
+        href="${tg.paginate.get_href(1, col.getter.__dict__.get('name', col.name), col.get_option('reverse_order', False))}"
+        py:content="col.title"/>
+    </th>
+  </tr>
+</thead>
+<tbody>
+  <tr py:for="i, row in enumerate(value)" class="${i%2 and 'odd' or 'even'}">
+    <td py:for="col in columns" align="${col.get_option('align', None)}"
+      py:content="col.get_field(row)"/>
+  </tr>
+</tbody>
+</table>
Index: turbogears/widgets/big_widgets.py
===================================================================
--- turbogears/widgets/big_widgets.py	(revision 4755)
+++ turbogears/widgets/big_widgets.py	(working copy)
@@ -207,6 +207,7 @@
             search_controller="%s/search" % self.full_class_name,
             search_param="state", result_name="states")
 
+    [expose(format="json")]
     def search(self, state):
         states = []
         code = state.upper()
@@ -216,7 +217,6 @@
             states.extend([s for s  in zip(self.states, self.codes)
                 if s[0].lower().startswith(state.lower())])
         return dict(states=states)
-    search = expose(format="json")(search)
 
 
 class AutoCompleteTextField(TextField, AutoComplete):
@@ -261,6 +261,7 @@
             search_controller="%s/search" % self.full_class_name,
             search_param="state", result_name="states")
 
+    [expose(format="json")]
     def search(self, state):
         states = []
         code = state.upper()
@@ -270,7 +271,6 @@
             states.extend([s for s  in self.states
                 if s.lower().startswith(state.lower())])
         return dict(states=states)
-    search = expose(format="json")(search)
 
 
 class LinkRemoteFunction(RPC):
@@ -310,10 +310,10 @@
             name="state", action="%s/search_linkrf" % self.full_class_name,
             data = dict(state_starts_with="N"))
 
+    [expose()]
     def search_linkrf(self, state_starts_with):
         return '<br/>'.join(filter(
             lambda item: item.startswith(state_starts_with), self.states))
-    search_linkrf = expose()(search_linkrf)
 
 
 class RemoteForm(RPC, TableForm):
@@ -360,9 +360,9 @@
             confirm = "Confirm?",
         )
 
+    [expose()]
     def post_data_rf(self, **kw):
         return """Received data:<br/>%r""" % kw
-    post_data_rf = expose()(post_data_rf)
 
 
 ajaxgridcounter = itertools.count()
@@ -431,12 +431,12 @@
         )
         self.update_count = itertools.count()
 
+    [expose(format="json")]
     def update(self):
         return dict(
             headers = ["N", "fact(N)"],
             rows = list(self.facgen(self.update_count.next())),
         )
-    update = expose(format="json")(update)
 
 
 class URLLink(FormField):
Index: turbogears/view/base.py
===================================================================
--- turbogears/view/base.py	(revision 4755)
+++ turbogears/view/base.py	(working copy)
@@ -13,7 +13,8 @@
 import turbogears
 from turbogears import identity, config
 from turbogears.i18n import i18n_filter, get_locale
-from turbogears.util import DictObj, DictWrapper, get_template_encoding_default, adapt_call
+from turbogears.util import Bunch, get_template_encoding_default, \
+    adapt_call, deprecated
 
 log = logging.getLogger("turbogears.view")
 
@@ -22,27 +23,22 @@
 root_variable_providers = []
 engines = dict()
 
-# Deprecation of variableProviders
-def print_warning(func):
-    def _print_warning(*args, **kw):
-        import warnings
-        warnings.warn(
-            "Use of variableProviders is deprecated, use variable_providers"
-            "instead.",
-            DeprecationWarning, 2)
-        return func(*args, **kw)
-    return _print_warning
 
 class MetaDeprecatedVariableProviders(type):
+
     def __new__(cls, name, bases, dict):
-        for (key, value) in dict.items():
+        deprecate = deprecated(
+            "Use variable_providers instead of variableProviders.")
+        for key, value in dict.items():
             if key == "__metaclass__":
                 continue
             if callable(value):
-                dict[key] = print_warning(value)
+                dict[key] = deprecate(value)
         return type.__new__(cls, name, bases, dict)
 
+
 class DeprecatedVariableProviders(list):
+
     __metaclass__ = MetaDeprecatedVariableProviders
 
     def append(self, *args, **kw):
@@ -74,6 +70,7 @@
 
 variableProviders = DeprecatedVariableProviders()
 
+
 def _choose_engine(template):
     if isinstance(template, basestring):
         colon = template.find(":")
@@ -94,50 +91,75 @@
     return engine, template, enginename
 
 
-def render(info, template=None, format=None, content_type=None, mapping=None, fragment=False):
+def render(info, template=None, format=None, headers=None,
+        mapping=None, fragment=False):
     """Renders data in the desired format.
 
     @param info: the data itself
     @type info: dict
     @param format: "html", "xml" or "json"
     @type format: string
+    @param headers: for response headers, primarily the content type
+    @type headers: dict
     @param fragment: passed through to tell the template if only a
                      fragment of a page is desired
     @type fragment: bool
     @param template: name of the template to use
     @type template: string
+
     """
     template = info.pop("tg_template", template)
     if not info.has_key("tg_flash"):
         if config.get("tg.empty_flash", True):
             info["tg_flash"] = None
     engine, template, enginename = _choose_engine(template)
-    if  not content_type and getattr(engine, 'get_content_type', None):
-        ua = getattr(cherrypy.request.headers, "User-Agent", None)
-        ua = UserAgent(ua)
-        content_type = engine.get_content_type(ua)
-    elif not content_type:
-        content_type = "text/html"
-    if content_type == 'text/html' and enginename in ('genshi', 'kid'):
-        charset = get_template_encoding_default(enginename)
-        content_type = content_type + '; charset=' + charset
-    cherrypy.response.headers["Content-Type"] = content_type
     if not format:
-        format = config.get("%s.outputformat" % enginename, "html")
+        format = enginename == 'json' and 'json' or config.get(
+            "%s.outputformat" % enginename, 'html')
+
+    if isinstance(headers, dict):
+        # Determine the proper content type and charset for the response.
+        # We simply derive the content type from the format here
+        # and use the charset specified in the configuration setting.
+        # This could be improved by also examining the engine and the output.
+        content_type = headers.get('Content-Type')
+        if not content_type:
+            if format:
+                content_format = format
+                if isinstance(content_format, (tuple, list)):
+                    content_format = content_format[0]
+                content_format = content_format.split()[0].split('-' , 1)[0]
+            else:
+                content_format = 'html'
+            content_type = {'html': 'text/html', 'xml': 'text/xml',
+                'json': 'application/json'}.get(content_format, 'text/html')
+        if content_type.startswith(
+                'text/') and '; charset=' not in content_type:
+            charset = get_template_encoding_default(enginename)
+            if charset:
+                content_type += '; charset=' + charset
+        headers['Content-Type'] = content_type
+
     args, kw = adapt_call(engine.render, args= [],
-                kw = dict(info=info, format=format, fragment=fragment, template=template, mapping=mapping), start=1)
+        kw = dict(info=info, format=format, fragment=fragment,
+        template=template, mapping=mapping), start=1)
+
     return engine.render(**kw)
 
+
 def transform(info, template):
-    "Create ElementTree representation of the output"
+    """Create ElementTree representation of the output."""
     engine, template, enginename = _choose_engine(template)
     return engine.transform(info, template)
 
+
 def loadBaseTemplates():
-    """Loads base templates for use by other templates.
-    By listing templates in turbogears.view.baseTemplates, these templates will
-    automatically be loaded so that the "import" statement in a template
-    will work.
+    """Load base templates for use by other templates.
+
+    By listing templates in turbogears.view.baseTemplates,
+    these templates will automatically be loaded so that
+    the "import" statement in a template will work.
+
     """
     log.debug("Loading base templates")
     for template in baseTemplates:
@@ -146,62 +168,61 @@
             del sys.modules[template]
         engine.load_template(template)
 
-NOTGIVEN = []
 
 class cycle:
-    """
-    Loops forever over an iterator. Wraps the itertools.cycle method
-    but provides a way to get the current value via the 'value' attribute
+    """Loops forever over an iterator.
 
-    >>> from turbogears.view.base import cycle
-    >>> oe = cycle(('odd','even'))
-    >>> oe
-    None
-    >>> oe.next()
-    'odd'
-    >>> oe
-    'odd'
-    >>> oe.next()
-    'even'
-    >>> oe.next()
-    'odd'
-    >>> oe.value
-    'odd'
+    Wraps the itertools.cycle method, but provides a way to get the current
+    value via the 'value' attribute.
+
     """
     value = None
+
     def __init__(self, iterable):
         self._cycle = icycle(iterable)
+
     def __str__(self):
         return self.value.__str__()
+
     def __repr__(self):
         return self.value.__repr__()
+
     def next(self):
         self.value = self._cycle.next()
         return self.value
 
 
 def selector(expression):
-    """If the expression is true, return the string 'selected'. Useful for
-    HTML <option>s."""
+    """If the expression is true, return the string 'selected'.
+
+    Useful for HTML <option>s.
+
+    """
     if expression:
         return "selected"
     else:
         return None
 
+
 def checker(expression):
-    """If the expression is true, return the string "checked". This is useful
-    for checkbox inputs.
+    """If the expression is true, return the string "checked".
+
+    This is useful for checkbox inputs.
+
     """
     if expression:
         return "checked"
     else:
         return None
 
+
 def ipeek(it):
-    """Lets you look at the first item in an iterator. This is a good way
-    to verify that the iterator actually contains something. This is useful
-    for cases where you will choose not to display a list or table if there
-    is no data present.
+    """Lets you look at the first item in an iterator.
+
+    This is a good way to verify that the iterator actually contains something.
+    This is useful for cases where you will choose not to display a list or
+    table if there is no data present.
+
     """
     it = iter(it)
     try:
@@ -210,16 +231,18 @@
     except StopIteration:
         return None
 
-safariua = re.compile(r"Safari/(\d+)")
 
 class UserAgent:
     """Representation of the user's browser.
 
-    Provides information about the type of browser, browser version,
-    etc. This currently contains only the information needed for work
-    thus far. (msie, firefox, safari browser types, plus safari version
-    info.)
+    Provides information about the type of browser, browser version, etc.
+    This currently contains only the information needed for work thus far
+    (msie, firefox, safari browser types, plus safari version info).
+
     """
+
+    _re_safari = re.compile(r"Safari/(\d+)")
+
     def __init__(self, useragent=None):
         self.majorVersion = None
         self.minorVersion = None
@@ -230,7 +253,7 @@
         elif useragent.find("Firefox") > -1:
             self.browser = "firefox"
         else:
-            isSafari = safariua.search(useragent)
+            isSafari = self._re_safari.search(useragent)
             if isSafari:
                 self.browser = "safari"
                 build = int(isSafari.group(1))
@@ -253,21 +276,22 @@
             else:
                 self.browser = "unknown: %s" % useragent
 
-class DeprecatedDictWrapper(DictWrapper):
+
+class DeprecatedBunch(Bunch):
     """Wraps access with a deprecation warning."""
 
     def __getattr__(self,name):
         import warnings
-        warnings.warn(
-            "The use of 'std' inside your templates is deprecated,"
-            " use 'tg' instead.",
+        warnings.warn("Use 'tg' instead of 'std' inside your templates.",
             DeprecationWarning, 2)
-        return super(DeprecatedDictWrapper, self).__getattr__(name)
+        return super(DeprecatedBunch, self).__getattr__(name)
 
+
 def stdvars():
-    """Creates an DictObj with variables that should be available in all
-    templates. These variables are:
+    """Create a Bunch of variables that should be available in all templates.
 
+    These variables are:
+
     useragent
         a UserAgent object with information about the browser
     selector
@@ -302,9 +326,9 @@
         the cherrypy config get function
 
     Additionally, you can add a callable to turbogears.view.variable_providers
-    that can add more variables to this list. The callable will be
-    called with the vars DictObj after these standard variables have
-    been set up.
+    that can add more variables to this list. The callable will be called with
+    the vars Bunch after these standard variables have been set up.
+
     """
     try:
         useragent = cherrypy.request.headers["User-Agent"]
@@ -317,7 +341,7 @@
     else:
         session = None
 
-    vars = DictObj(
+    vars = Bunch(
         useragent=useragent, selector=selector,
         tg_js="/" + turbogears.startup.webpath + "tg_js",
         tg_toolbox="/" + turbogears.startup.webpath + "tg_toolbox",
@@ -332,13 +356,14 @@
         request = cherrypy.request)
     for provider in variable_providers + variableProviders:
         provider(vars)
-    deprecated_vars = DeprecatedDictWrapper(vars)
+    deprecated_vars = DeprecatedBunch(vars)
     root_vars = dict()
     for provider in root_variable_providers:
         provider(root_vars)
     root_vars.update(dict(tg=vars, std=deprecated_vars))
     return root_vars
 
+
 def load_engines():
     """Load and initialize all templating engines.
 
@@ -347,24 +372,31 @@
     the engines will then be reloaded with the custom configuration later.
 
     """
-    conf = turbogears.config.get
+    get = config.get
     engine_options = {
-        "cheetah.importhooks": conf("cheetah.importhooks", False),
-        "cheetah.precompiled": conf("cheetah.precompiled", False),
-        "genshi.encoding": conf("genshi.encoding", "utf-8"),
-        "genshi.default_doctype": conf("genshi.default_doctype", None),
-        "genshi.lookup_errors": conf("genshi.lookup_errors", "strict"),
-        "kid.encoding": conf("kid.encoding", "utf-8"),
-        "kid.assume_encoding": conf("kid.assume_encoding", "utf-8"),
-        "kid.precompiled": conf("kid.precompiled", False),
-        "kid.i18n.run_template_filter":
-            conf("i18n.run_template_filter", False),
+        "cheetah.importhooks": get("cheetah.importhooks", False),
+        "cheetah.precompiled": get("cheetah.precompiled", False),
+        "genshi.encoding": get("genshi.encoding", "utf-8"),
+        "genshi.default_doctype": get("genshi.default_doctype", None),
+        "genshi.lookup_errors": get("genshi.lookup_errors", "strict"),
+        "genshi.loader_callback" : get("genshi.loader_callback", None),
+        "json.skipkeys": get("json.skipkeys", False),
+        "json.sort_keys": get("json.sort_keys", False),
+        "json.check_circular": get("json.check_circular", True),
+        "json.allow_nan": get("json.allow_nan", True),
+        "json.indent": get("json.indent", None),
+        "json.separators": get("json.separators", None),
+        "json.ensure_ascii": get("json.ensure_ascii", False),
+        "json.assume_encoding": get("json.assume_encoding", "utf-8"),
+        "kid.encoding": get("kid.encoding", "utf-8"),
+        "kid.assume_encoding": get("kid.assume_encoding", "utf-8"),
+        "kid.precompiled": get("kid.precompiled", False),
+        "kid.i18n.run_template_filter": get("i18n.run_template_filter", False),
         "kid.i18n_filter": i18n_filter,
-        "kid.sitetemplate": conf("tg.sitetemplate",
-            "turbogears.view.templates.sitetemplate"),
-        "kid.reloadbases": conf("kid.reloadbases", False),
-        "mako.directories": conf("mako.directories", []),
-        "mako.output_encoding": conf("mako.output_encoding", "utf-8")
+        "kid.sitetemplate": get("tg.sitetemplate", "turbogears.view.templates.sitetemplate"),
+        "kid.reloadbases": get("kid.reloadbases", False),
+        "mako.directories": get("mako.directories", []),
+        "mako.output_encoding": get("mako.output_encoding", "utf-8")
     }
     for entrypoint in pkg_resources.iter_entry_points(
             "python.templating.engines"):
